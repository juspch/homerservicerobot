-added my old my_world from my_robot into the turtlebot gazebo files. then used the gmapping package and map server to create a crude map of the world. this was saved on desktop and then move to the turtlebotsimulator folder

-Made little changes to the original code for pick_objects and add_markers (the ones for test launches). Had these renamed to pick_objects_test and add_markers_test and generated the additional executables for the launch files.

-rewrote the code for both pick_objects and add_markers. originally, i tried to use the amcl_pose topic to sequence out the events for picking up and dropping objects, however, i couldn't get reliable results since the x and y coordinates from amcl did not match the exact coordinates i plugged in. so instead of using position as a trigger for dropping in and removing markers, i made a new topic instead to which both pick_objects and add_markers subscribed and published to so that i could just ping that topic whenever a process concluded.

-the new topic (/pick_up) utilized the same visualization::marker_msg format and i used the marker namespace to attach specific strings while using if, if-else statements in the callback functions for pick_objects or add_markers nodes to control which msgs were process by which nodes. this was necessary since both the subscribers for the pick_objects and add_markers nodes subscribe to the same topic. the code is set up in a way where the pick_objects node is continually provided goal targets by the add_markers node, while the add_markers node adds or removes markers from the visualization_marker topic depending on the msg sent by pick_object. given the way the both topics were written, you only need to define the pick up and drop zone coordinates from the add_markers.cpp

- it starts with the pick_objects node being started and waiting for a target goal. when add_markers node is started, it will generate the pick up zone marker and publish it to both /visualization_marker and /pick_up so the marker both shows up on rviz and is also received by pick_objects. pick_objects uses the pose information in the msg and uses actionlib to set a nav goal for the robot. the robot is told to wait for 5 seconds before a new msg is then sent out by pick_objects to /pick_up, signalling the add_markers node that the robot is at the pickup location. add_markers then sends a msg to rviz to delete the original marker while also sending the drop off zone coordinates back to pick_objects node. pick_objects again uses the pose information in the msg to send a nav goal to the drop off zone and again sends a msg when the robot reaches the drop off zone. add_markers then sends a msg to rviz to add the marker at the drop off zone. this marker is set to last for 30 seconds. as an added touch, add_markers then sends a msg back to pick_objects that tells it to go back to origin. again, if-else statements in the call back function were used to control what statements would be processed by which nodes. for example, pick_objects would only process the msgs that contained location namespaces like "pickup" or "dropoff" or "origin". on the other hand, the add_markers node only processes namespaces that described processes like "pickup reached" or "dropoff reached".
